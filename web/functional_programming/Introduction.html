<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../web/css/common.css" type="text/css" charset="utf-8" />
<link rel="stylesheet" href="../js/highlight/styles/default.css">
<script type="text/javascript" src="../js/highlight/highlight.pack.js"></script>
<script>
  hljs.tabReplace = '    ';
  hljs.initHighlightingOnLoad();
</script>

<title>Introduction to Functional Programming</title>
</head>
<body>

首先我们要明白的是，函数式编程是另外一种编程方式，而不是另外一门语言。
也许大家平时在很多技术的报道和文章，关于Erlang，Scala，Clojure, Google Go, F#等等的时候

熟悉Java的人学习C#会很快上手，同样学习Python，Ruby等也不会遇到太多的问题。原因是这些语言都是命令式编程（Imperative programming）风格的语言。


而在学习Erlang，Scala，



浅析函数式编程与命令式编程

声明式编程（英语：Declarative programming）是一种编程范型，采用了和命令式编程对立的方向。它描述目目标性质，让电脑明白目标是什么。
声明式编程通过函数、推论规则或项重写（term-rewriting）规则，来描述变量之间的关系。它的语言运行器（编译器或解释器）采用了一个固定的算法，以从这些关系产生结果。

模范语言

声明式编程包含了函数式编程和逻辑编程，故采用这两种编程范型的编程语言如Prolog或Haskell都属声明式编程。其他例子有SQL。


函数式编程语言

函数式编程（英语：Functional programming），又称泛函编程，是一种编程范型，它将电脑运算视为数学上的函数计算，并且避免状态以及可变数据。函数编程语言最重要的基础是 λ 演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。
和命令式编程相比，函数式编程强调函数的计算比指令的运行重要。
和程序编程相比，函数式编程里，函数的计算可随时调用。

函数式编程经常使用递归。
纯函数式的程序没有变量和副作用(Side effect)。因为纯函数式程序设计语言没有变量，函数没有副作用，编写出的程序可以利用记忆化、公共子表达式消除和并发计算在运行时和编译时得到大量优化。

知道Python的人学习Ruby可能不会遇到太多的问题，
知道Java的人学习C#会感到很熟悉。
不错，也有意外的地方。Ruby爱好者在学习Python时会对它的comprehension感到吃惊，Java用户会对C#里的委派摸不着头脑。
还是那句话，如果你只瞟一眼，它们都很相似。



2.花时间学习函数式编程是有必要的


                                                      

在绝大多数的IT公司里，主流的语言都是Java, Python, Ruby, C#等面向对象的编程语言。

如果你说你只懂函数式编程语言，例如Haskell，Erlang，Scala， F#或某个Lisp方言来编程，很可能找不到 对应的职位。

也许会偶然用到一两个“函数式语言特征”，例如“block”，但人们不会去做函数式编程。
很多年来，我们一直被教导说函数式编程语言很好很棒。

但学习函数式编程，学习这种新的、函数式的语言“对你有好处”；就像是某些人建议说每天30分钟的健身房活动会“让你的身体健康”一样。
但这也同时暗示了这样做的难度和需要的付出。Lisp语言跟Haskell、Ocaml和Scala语言不同，被认为是出了名的难学，可以说是臭名昭著。
文雅的人说这是Lisp语言的“深度&广度”的体现。不文雅的人说这是“意淫”或“玩弄学术”或简单的“没必要”。
我认为，它的难度跟你对它熟不熟悉有关，而且，这种难度是一种重要指标显示：学习这样的一种语言会让你编程更有效率、能力更强。




大概10岁时我学了C语言，但遇到了一堵越不过去的墙，直到我上了高中。那就是：指针。即使不算这些该死的指针，我写、读、学习、练习中，同样遭遇无数的失败。我把祖父的硬盘给毁掉了两次(一次属意外)，最后弄得不少次要自己重装操作系统。我失败，一遍遍的失败。

也许你也有跟我相似的故事，也许是完全不同的一个。但我想，差不多所有学过编程的人都有过遇到困难的经历。我们在学了一些基本知识后，必然会遇到一些公认的概念上的关口，比如“指针”。很多计算机科学教授会把指针描述为他们课程上的过滤网。如果你想成为一名优秀的程序员，你必须要能理解指针。很少人能轻松的掌握它们。大多数人，包括我，则需要不断的练习和参考例子来理解什么是指针、为什么它们很重要。

这种艰难的努力过程不是偶然的，是一种几乎普遍的现象。指针是一种非常强大和基础功能的概念。学会它能让你成为一名更好的程序员，能让你的思考更加形象化。即使你使用的语言并不提供指针这样的特征，但跟指针类似的数据结构和概念却随处可见。

一旦你学会了几种语言后，所有的语言都开始看起来都很相似。
知道Python的人学习Ruby可能不会遇到太多的问题，
知道Java的人学习C#会感到很熟悉。
不错，也有意外的地方。Ruby爱好者在学习Python时会对它的comprehension感到吃惊，Java用户会对C#里的委派摸不着头脑。
还是那句话，如果你只瞟一眼，它们都很相似。我可以打保票的说，如果你还不曾有过这样的认识，一旦你学了一种Lisp语言，你会发现所有的Lisp变种都很相似。

有人说，大部分人第一次使用Haskell或Ocaml时都完全的不知所措。见鬼了，在Haskell里，连分号都跟别人不一样。这并不是语法的问题；Haskell和ML语言完全基于一种不同的概念、一种新的语言范式。你需要用不同的方式开发应用，不同的方式组织应用，不同的方式扩展应用。

很多这样的新概念都具有不可思议的强大力量。Haskell里的Monads 是跟指针一样基础且强大的概念(你很可能在不知道它叫什么的情况下就已经使用过它们了)。所以，跟学了Java后再学C#不一样，有志向学习函数式语言的人需要往回走的更远，去学习更加基础的概念后才能接下去学习。就像是完全再学习一次指针。并且，就像是当年我们刚开始学习编程一样，一些很大的概念看起来会让人迷惑茫然，让人沮丧，直到你去攻克(以及失败)它们。


很多人不情愿在函数式编程学习中投入时间。很容易理解这种不情愿，“我干嘛不把花在学习这些东西的时间用在实现什么东西上呢？”但这种思路也表明了你永远不愿意在任何新技术上浪费时间(只用自己熟悉的)。在一个像软件技术这样日新月异的产业里，我不认为这是正确的判断。



当你开始学的时候，请注意，不要过于在意。就像其他任何需要你花时间和精力的事情一样，过度的在函数式编程上进行精力上的投资是很危险的。掉进了认知能力的陷阱后你的投资会血本无归。你很容易会忘掉世界上还有无数种计算模型，你更容易忘掉有多少种优秀的软件根本没有使用任何的函数式概念。

学习的道路会越来越难走，但从另一方面说，在你日常的编程中，你会发现有越来越多的可以使用的重要概念和模型。对于这样紧凑的编程风格你会越来越适应，必然，你也会对如何成为一名更好的软件工程师有了新的认识。

今天听徐x在BJUG上大谈Scheme，私下又讨论了一下。觉得有两点结论颇为有意思，是关于fp和ip之间的。
　　1、使用fp写算法的时候经常希望用set!。但是使用了set!就有side-effect了。为了保持fp的相关优点不受到破坏，徐x同学使用了以下两种方式：
　　a、使用另外一种非直觉，但是fp的方式来写算法。当然算法的易懂性和执行效率就受到了损害。
　　b、使用stream，进行lazy求值，但是只适合分阶段计算，两个阶段中间没有明确的关系，把第一阶段的值“放”到stream中。其实这个和传一个high-order function进去是一样的。
　　2、徐x同志说用java的时候能有c的DEFINE就好了。其实c的宏是很弱的。ip中做meta programming比较强的有MASM和C++的模板。前者的编译期计算的能力达到了图灵完备的程度，后者也基本上无所不能了，虽然做得很 tricky。但是两者的meta programming都遇到了很多问题。基本上都是因为调试测试的问题而被广大人民群众所唾弃。我就觉得很奇怪了，为什么lisp就没有这个问题。后来我想明白了，其实对于lisp来说，宏展开和计算是一回事。但是对于ip来说，宏展开是一个和程序机器语义执行完全不同的过程。当一段程序我们要对他进行机器语义的解毒已经颇为不易了(因为不光有算法，还有时序)，现在还要加一个符号计算的宏展开，基本上只有天才才能读的东西了。
　　所以，最终我的一个结论是，两者都有很大缺陷。fp不是越pure越好用，ip也应该用合适的方式借鉴一些fp的东西，但是不要照搬一套meta系统过来。




诞生50多年之后，函数式编程（functional programming）开始获得越来越多的关注。
不仅最古老的函数式语言Lisp重获青春，而且新的函数式语言层出不穷，比如Erlang、clojure、Scala、F#等等。
目前最当红的Python、Ruby、Javascript，对函数式编程的支持都很强，就连老牌的面向对象的Java、面向过程的PHP，都忙不迭地加入对匿名函数的支持。
越来越多的迹象表明，函数式编程已经不再是学术界的最爱，开始大踏步地在业界投入实用。
也许继"面向对象编程"之后，"函数式编程"会成为下一个编程的主流范式（paradigm）。未来的程序员恐怕或多或少都必须懂一点。

但是，"函数式编程"看上去比较难，缺乏通俗的入门教程，各种介绍文章都充斥着数学符号和专用术语，让人读了如坠云雾。就连最基本的问题"什么是函数式编程"，网上都搜不到易懂的回答。
下面是我的"函数式编程"学习笔记，分享出来，与大家一起探讨。
内容不涉及数学（我也不懂Lambda Calculus），也不涉及高级特性（比如lazy evaluation和currying），
只求尽量简单通俗地整理和表达，我现在所理解的"函数式编程"以及它的意义。
我主要参考了Slava Akhmechet的"Functional Programming For The Rest of Us"。

一、定义

简单说，"函数式编程"是一种"编程范式"（programming paradigm），也就是如何编写程序的方法论。
它属于"结构化编程"的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。举例来说，现在有这样一个数学表达式：
　　(1 + 2) * 3 - 4
传统的过程式编程，可能这样写：
　　var a = 1 + 2;
　　var b = a * 3;
　　var c = b - 4;
函数式编程要求使用函数，我们可以把运算过程定义为不同的函数，然后写成下面这样：
　　var result = subtract(multiply(add(1,2), 3), 4);
这就是函数式编程。
二、特点

函数式编程具有五个鲜明的特点。
1. 函数是"第一等公民"

所谓"第一等公民"（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。
举例来说，下面代码中的print变量就是一个函数，可以作为另一个函数的参数。
　　var print = function(i){ console.log(i);};

　　[1,2,3].forEach(print);

2. 只用"表达式"，不用"语句"

"表达式"（expression）是一个单纯的运算过程，总是有返回值；"语句"（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。
原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。"语句"属于对系统的读写操作，所以就被排斥在外。
当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。

3. 没有"副作用"

所谓"副作用"（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。
函数式编程强调没有"副作用"，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。

4. 不修改状态

上一点已经提到，函数式编程只是返回新的值，不修改系统变量。因此，不修改变量，也是它的一个重要特点。
在其他类型的语言中，变量往往用来保存"状态"（state）。不修改变量，意味着状态不能保存在变量中。函数式编程使用参数保存状态，最好的例子就是递归。下面的代码是一个将字符串逆序排列的函数，它演示了不同的参数如何决定了运算所处的"状态"。
　　function reverse(string) {
　　　　if(string.length == 0) {
　　　　　　return string;
　　　　} else {
　　　　　　return reverse(string.substring(1, string.length)) + string.substring(0, 1);
　　　　}
　　}
由于使用了递归，函数式语言的运行速度比较慢，这是它长期不能在业界推广的主要原因。
5. 引用透明

引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或"状态"，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。
有了前面的第三点和第四点，这点是很显然的。其他类型的语言，函数的返回值往往与系统状态有关，不同的状态之下，返回值是不一样的。这就叫"引用不透明"，很不利于观察和理解程序的行为。
三、意义

函数式编程到底有什么好处，为什么会变得越来越流行？
1. 代码简洁，开发快速

函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快。
Paul Graham在《黑客与画家》一书中写道：同样功能的程序，极端情况下，Lisp代码的长度可能是C代码的二十分之一。
如果程序员每天所写的代码行数基本相同，这就意味着，"C语言需要一年时间完成开发某个功能，Lisp语言只需要不到三星期。反过来说，如果某个新功能，Lisp语言完成开发需要三个月，C语言需要写五年。"当然，这样的对比故意夸大了差异，但是"在一个高度竞争的市场中，即使开发速度只相差两三倍，也足以使得你永远处在落后的位置。"


2. 接近自然语言，易于理解

函数式编程的自由度很高，可以写出很接近自然语言的代码。
前文曾经将表达式(1 + 2) * 3 - 4，写成函数式语言：
　　subtract(multiply(add(1,2), 3), 4)
对它进行变形，不难得到另一种写法：
　　add(1,2).multiply(3).subtract(4)
这基本就是自然语言的表达了。再看下面的代码，大家应该一眼就能明白它的意思吧：
　　merge([1,2],[3,4]).sort().search("2")
因此，函数式编程的代码更容易理解。


3. 更方便的代码管理

函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。


4. 易于"并发编程"

函数式编程不需要考虑"死锁"（deadlock），因为它不修改变量，所以根本不存在"锁"线程的问题。不必担心一个线程的数据，被另一个线程修改，所以可以很放心地把工作分摊到多个线程，部署"并发编程"（concurrency）。
请看下面的代码：
　　var s1 = Op1();
　　var s2 = Op2();
　　var s3 = concat(s1, s2);
由于s1和s2互不干扰，不会修改变量，谁先执行是无所谓的，所以可以放心地增加线程，把它们分配在两个线程上完成。其他类型的语言就做不到这一点，因为s1可能会修改系统状态，而s2可能会用到这些状态，所以必须保证s2在s1之后运行，自然也就不能部署到其他线程上了。
多核CPU是将来的潮流，所以函数式编程的这个特性非常重要。
5. 代码的热升级

函数式编程没有副作用，只要保证接口不变，内部实现是外部无关的。所以，可以在运行状态下直接升级代码，不需要重启，也不需要停机。Erlang语言早就证明了这一点，它是瑞典爱立信公司为了管理电话系统而开发的，电话系统的升级当然是不能停机的。
作者：阮一峰
原文网址：http://www.ruanyifeng.com/blog/2 ... al_programming.html
扩展阅读
请问下如何试通过51的P2.4端口通过编程的方式在产生一个500KHZ的时钟信号供0809使用？
C++编程思想（pdf电子书）
autodesk的一道编程面试题，大家试试吧
C语言可否实现面向对象编程？如何实现面向对象编程？
DSP 混合编程
开放出版：许式伟《Go语言编程》样章“面向对象编程”
Google Go语言近况 Android平台工作加速
6410中断控制
LLVM 与 Clang 介绍
socket编程所需头文件讲解


FAQ:
如何启动和停止？
启动 erl
停止 Ctrl+C, q().

如何编译运行？
c(examples).
examples:len([1,2,3]).

记得在表达式的最后别忘记用英文句点(.)来终止，然后按回车来完成。
如果你的输入结束时没有输入句点，那么Erlang终端就不会对你的输入值进行求值








     

     

</body>
</html>