<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../css/common.css" type="text/css" charset="utf-8" />
<title>Semaphore</title>
</head>
<body>
<div id="container">

<div style="ffl">
Semaphore当前在多线程环境下被扩放使用，操作系统的信号量是个很重要的概念，在进程控制方面都有应用。Java 并发库 的Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。比如在Windows下可以设置共享文件的最大客户端访问个数。 
Semaphore实现的功能就类似厕所有5个坑，假如有10个人要上厕所，那么同时只能有多少个人去上厕所呢？同时只能有5个人能够占用，当5个人中 的任何一个人让开后，其中等待的另外5个人中又有一个人可以占用了。另外等待的5个人中可以是随机获得优先机会，也可以是按照先来后到的顺序获得机会，这取决于构造Semaphore对象时传入的参数选项。单个信号量的Semaphore对象可以实现互斥锁的功能，并且可以是由一个线程获得了“锁”，再由另一个线程释放“锁”，这可应用于死锁恢复的一些场合。

Semaphore维护了当前访问的个数，提供同步机制，控制同时访问的个数。在数据结构中链表可以保存“无限”的节点，用Semaphore可以实现有限大小的链表。另外重入锁 ReentrantLock 也可以实现该功能，但实现上要复杂些。 
下面的Demo中申明了一个只有5个许可的Semaphore，而有20个线程要访问这个资源，通过acquire()和release()获取和释放访问许可。
</div>

<div style="ffl">
<a href="http://en.wikipedia.org/wiki/Readers-writers_problem">Reader/Writer Problem</a>
读者／写者问题
<a href="../../code/java/src/org/mywiki/cp/ThreadSync.java">Java example code</a>

Q&A: <br>
- different between Procedure/Consumer and Reader/Writer
	<div>
	The answer is: locking is necessary if (and only if) both threads can use the same shared resources at the same time. There isn't enough information about your specific implementation, but I have few remarks:
	Locking only during writing makes no sense. It only adds some overhead, but not prevent from any concurrent access until the reader is also correctly locked.
	Locking would be necessary if file operations which modify structures connected with the file's descriptors are not synchronized in any way. It may happen that P1 could start writing to the file when P2 is still reading. If reading and writing operations modify the same system structures without any underlying synchronization you will end up with corrupted data. It's hard to say if this is the case here because you didn't mention which particular function (libraries) you used. File operations are synchronized on most systems, so it shouldn't be a problem.
	From what you wrote about "10 bytes portions of information", the explicit locking seems to be not necessary (unless #2 doesn't impose it). P1 produces quantum of data. When the data is ready to be read P1 notifies P2 about that (by the event; event passing should be internally synchronized, anyhow). P2 knows that it could read quantum of data and then needs to wait for subsequent notification. It may happen that subsequent notification would be sent before previous one is handled. So, the events needs to be queued somehow. You can also use semaphore instead of events notification.
	
	</div>
</div>

<div style="ffl">
<a href="http://en.wikipedia.org/wiki/Shortest_job_next">Shortest Job Next</a>
</div>

<div style="ffl">
<a href="http://en.wikipedia.org/wiki/Shortest_job_next">Execution Order</a>
按指定顺序依赖关系来执行任务
</div>


<div style="ffl">
<a href="http://en.wikipedia.org/wiki/Sleeping_barber_problem">sleeping barber problem</a>
http://isida.blogbus.com/logs/36563268.html
</div>

<div style="ffl">
<a href="http://syncgen.projects.cis.ksu.edu/documentation/examples/birds.shtml">The Hungry Birds Problem  (one producer - multiple consumers)</a>
Given are N baby birds and one parent bird. The baby birds eat out of a common dish that initially contains F portions of food. Each baby repeatedly eats one portion of food at a time, sleeps for a while, and then comes back to eat. When the dish becomes empty, the baby bird who empties the dish awakens the parent bird, which finds F portions of food and puts them in the dish. 
</div>



</div>
</body>
</html>