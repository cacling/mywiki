<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../css/common.css" type="text/css" charset="utf-8" />
<title>Monitor</title>
</head>
<body>
<div id="container"> 
	http://www.ibm.com/developerworks/cn/java/j-lo-synchronized/index.html
	
	在 Java 的版本中，我们不需要亲自开发 Scoped Lock，Thread Condition 类，Java 语言给我们提供了内建的支持，我们很容易使用 synchronized, wait/notify 这些 Java 特性来构建基于 Monitor Object 模式的应用。而缺点是：缺乏一些必要的灵活性。比如 : 在 Java 的版本中，我们并不能区分出 not empty 与 not full 这两个条件变量，所以我们只能使用 notifyAll 来通知所有等待者线程，而 C++ 版本使用了不同的通知唤醒：not_full_.notify 与 not_empty_.notify 。同样，在 Java 中对于 synchrnonized 的使用，后面一定要跟 {} 语句块，这在代码的书写上有些不灵活，而在 C++ 中的，Scoped Lock 默认就是保护当前的语句块，当然你也可以选择使用 {} 来显式声明。而且，使用 synchroninzed 所获得的对象锁，无法细粒度地区分是获得读锁还是写锁。
不过总的来说，Java 的确简化了基于 Monitor Object 并发模式的开发。不过，我们应该意识到，并发的实际应用开发决不会像 Java 语法这么体现出来的简单，简洁。我们更应该看到并发应用程序本质的一些东西，这有利于帮助我们构建更加健壮的并发应用。


	<div style="ffl">
	<a href="">xxxProblem</a>
	
	</div>

</div>
</body>
</html>