<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="../../web/css/common.css" type="text/css" charset="utf-8" />
<title></title>
</head>
<body>
<div id="container">

<div class="seg">

1. The Hungry Birds Problem  (one producer - multiple consumers)

Given are n baby birds and one parent bird. The baby birds eat out of a common dish that initially contains W worms. Each baby bird repeatedly takes a worm, eats it, sleeps for a while, takes another worm, and so on. If the dish is empty, the baby bird that discovers the empty dish chirps real loud to awaken the parent bird. The parent bird flies off and gathers W more worms, puts them in the dish, and then waits for the dish to be empty again. This pattern repeats forever.
Develop and implement a multithreaded program to simulate the actions of the birds. Represent the birds as concurrent threads (i.e. array of "babyBird" threads and a "parentBird" thread), and the dish as a critical shared resource that can be accessed by at most one bird at a time. Use only semaphores for synchronization. Your program should print a trace of interesting simulation events. Is your solution fair? Explain in comments to the source code.
2. The Bear and Honeybees Problem (multiple producers - one consumer)

Given are n honeybees and a hungry bear. They share a pot of honey. The pot is initially empty; its capacity is H portions of honey. The bear sleeps until the pot is full, then eats all the honey and goes back to sleep. Each bee repeatedly gathers one portion of honey and puts it in the pot; the bee, which fills the pot, awakens the bear.
Develop and implement a multithreaded program to simulate the actions of the bear and honeybees. Represent the bear and honeybees as concurrent threads (i.e. a "bear" thread and an array of "honeybee" threads), and the pot as a critical shared resource that can be accesses by at most one thread at a time. Use only semaphores for synchronization. Your program should print a trace of interesting simulation events. Is your solution fair (w.r.t. honeybees)? Explain in comments to the source code.
3. The One-Lane Bridge Problem (similar to the Readers/Writers problem) 

Cars coming from the north and the south arrive at a one-lane bridge. Cars heading in the same direction can cross the bridge at the same time, but cars heading in opposite direction cannot. 
(a) Develop and implement a multithreaded program that simulates cars and the bridge using only semaphores for synchronization. Represent the cars as threads. Each car should be a thread that crosses the bridge trips times, first in one direction, then in the other direction, and so on.  Assume that a car thread with an odd number first crosses the bridge in a northbound direction, and a car with an even number first crosses the bridge in a southbound direction. Have the cars sleep for a random amount of time between crossings of the bridge and have them sleep for a smaller random amount of time to simulate the time it takes to cross the bridge. Do not worry about fairness. Your program should print a trace of interesting simulation events. 
(b) Extra work. Modify your solution to ensure either of the following two options.
1.     Modify your solution to ensure fairness, i.e. to ensure that any car that is waiting to cross the bridge eventually gets to do so. You may want to solve the problem differently. See solutions to the Readers/Writers problem in Lecture 3.
2.     Modify your solution to ensure that cars cannot bypass each other on the bridge, i.e., cars leaves the bridge in the same order as they have entered the bridge.
In you will, you may develop and implement only one program (b) that covers (a).

4. The Unisex Bathroom Problem (similar to the Readers/Writers problem) 

Suppose there is only one bathroom in your department. It can be used by any number of men or any number of women, but not at the same time.
Develop and implement a multithreaded program that provides a fair solution to this problem using only semaphores for synchronization. Represent men and women as threads that repeatedly work (sleep for a random amount of time) and use the bathroom. Your program should allow any number of men or women to be in the bathroom at the same time. Your solution should ensure the required exclusion and avoid deadlock, and ensure fairness, i.e. ensure that any person (man or woman) which is waiting to enter the bathroom eventually gets to do so. Have the persons sleep for a random amount of time between visits to the bathroom and have them sleep for a smaller random amount of time to simulate the time it takes to be in the bathroom. Your program should print a trace of interesting simulation events. 
This problem is similar to the Readers/Writers problem (see Lecture 3).


1. A Fuel Space Station (a resource management problem)

Consider a future fuel station in space that supplies nitrogen and quantum fluid. Assume that the station has a capacity of handling V space vehicles in parallel and a maximum storage for N liters of nitrogen and for Q liters of quantum fluid. When a vehicle arrives at the station it requests the needed amount of fuel of the two different types or only one of the types. If there is not enough fuel of either type, the vehicle has to wait without blocking other vehicles. Special supply vehicles, one for each type of fuel, deliver fuel in fixed quantities. When a supply vehicle arrives at the station, it delays until there is enough space to deposit the delivered amount of fuel. To travel back, the supply vehicles also request a certain amount of fuel of the two different types or one of the types just like an ordinary vehicle, not necessarily the type it supplies.
(a) Develop a monitor (with condition variables) that controls the station. Define the monitor's operations and their implementation. Represent ordinary space vehicles and supply vehicles as threads and show how the monitor operations are used by the vehicle threads to get the fuel or to deposit the fuel. Also state which monitor signaling discipline you are using. Is your solution fair? Explain (in comments in the source code).
(b) Implement a multithreaded application in Java that simulates the actions of the space vehicles represented as concurrent threads and the fuel space station controlled by the monitor. Assume that each vehicle periodically arrives at the station to get/supply fuel. Have the vehicles sleep (pause) for a random amount of time between arriving at the station to simulate the time it takes to travel in space; and have the vehicles sleep (pause) for a smaller random amount of time to simulate the time it takes to get/supply the fuel at the station. Stop the simulation after each vehicle has arrived at the station trips (the given amount) times. Your program should print a trace of the interesting events in the program. 
2. A Repair Station  (a resource management problem)

A vehicle repair station can repair vehicles of three different types A, B and C. The station has the following capacity:
It can repair in parallel at most a, b, c vehicles of type A, B, C, correspondingly;
It can repair in parallel at most v vehicles of different types.
If a vehicle cannot be repaired because any (or both) of the above limitations, the vehicle has to wait until it can get a place to be repaired.

(a) Develop a monitor (with condition variables) that controls the station so that several vehicles can be repaired in parallel according to the capacity of the station as described above. Define the monitor's operations and their implementation. Represent vehicles as threads and show how they can use the monitor. Is your solution fair? Explain (in comments in the source code).
(b) Implement a multithreaded application in Java that simulates the actions of the vehicles represented as concurrent threads and the repair station represented as as the monitor. Assume that each vehicle periodically arrives at the station to get repaired. Have the vehicles sleep (pause) for a random amount of time between arriving at the station to simulate the time it takes to travel; and have the vehicles sleep (pause) for a smaller random amount of time to simulate the time it takes to be repaired at the station. Stop the simulation after each vehicle has arrived at the station trips (the given amount) times. Your program should print a trace of the interesting events in the program. 
3. The Dining Philosophers problem

Write a multithreaded program in Java to simulate the Dining Philosophers problem described in Lecture 3, Slide 18. There should be at least five threads, one per philosopher, and one shared object (a monitor) for the table. The shared object (monitor) "table" should have two methods: getforks(id) and relforks(id), where id is an integer between 1 an 5. Your solution need not to be fair.

Your program should have one command-line argument rounds that specifies the number of rounds of thinking and eating that each philosopher should execute. The philosophers should eat and think for random amounts of time. You may want to have additional command-line arguments, for example to control the eating and thinking intervals and the seed for the random number generator. Please give these default values so we can test your program using just one command-line argument. Describe additional arguments (if any) in a "USAGE..." help message. Your program should print a trace of the interesting events in the program. These events include when a thread call getforks, starts to eat, calls relforks, and starts to think. For each event, print a line containing a time stamp, a thread id, and a string describing the event. 

(Optional extra work). Your previous program should allow a philosopher to start eating as long as neither neighbor is eating. Modify your program so that philosophers get to start eating in first-come, first-served order. This means that if one philosopher has to wait to get permission to eat (because a neighbor is eating) and a second philosopher calls getforks, the second philosopher must wait, even if neither of its neighbors is eating. Hint: You might consider using tickets to order the waiting philosophers in getforks.
4. Yet Another Dining Philosophers problem (a.k.a. Dining in Hell), adapted from "The Art of Multiprocessor Programming" by Maurice Herlihy and Nir Shavit
In Dante’s Inferno, he describes a visit to Hell. In a very recently discovered chapter, he encounters five people sitting at a table with a pot of stew in the middle. Although each one holds a spoon that reaches the pot, each spoon’s handle is much longer than each person’s arm, so no one can feed him- or herself. They are famished and desperate. 
Dante then suggests “why do not you feed one another?” The rest of the chapter is lost.
Develop an algorithm to allow these five unfortunates to feed one another. Two or more people may not feed the same person at the same time. Your algorithm must be, well, starvation-free. Write a multithreaded program in Java to simulate the above problem using Java threads to represent the five unfortunates, and a shared concurrent object(s) to synchronize the threads so that can "feed" one another. The object(s) can be developed as monitor (i.e. synchronized objects). Your program should print a trace of the interesting events in the program. 
Implement the following problems from Lab 2 using monitors. You are not allowed to use semaphores in this lab.
5.  The Hungry Birds Problem  (one producer - multiple consumers)
Given are n baby birds and one parent bird. The baby birds eat out of a common dish that initially contains W worms. Each baby bird repeatedly takes a worm, eats it, sleeps for a while, takes another worm, and so on. If the dish is empty, the baby bird who discovers the empty dish chirps real loud to awaken the parent bird. The parent bird flies off and gathers W more worms, puts them in the dish, and then waits for the dish to be empty again. This pattern repeats forever.
Represent the birds as concurrent threads (i.e. array of "baby bird" threads and a "parent bird" thread), and the dish as a concurrent object (a monitor) that can be accessed by at most one bird at a time. 

Develop a monitor (with condition variables) to synchronize the actions of the birds, i.e. develop a monitor that represents the dish. Define the monitor's operations and their implementation. Implement a multithreaded application in Java to simulate the actions of the birds represented as concurrent threads and the dish represented as as the monitor. Is your solution fair? Explain in comments in the source code.

6.  The Bear and Honeybees Problem (multiple producers - one consumer)
Given are n honeybees and a hungry bear. They share a pot of honey. The pot is initially empty; its capacity is H portions of honey. The bear sleeps until the pot is full, then eats all the honey and goes back to sleep. Each bee repeatedly gathers one portion of honey and puts it in the pot; the bee who fills the pot awakens the bear.
Represent the bear and honeybees as concurrent threads (i.e. a "bear" thread and an array of "honeybee" threads), and the honey pot as a critical resource (a monitor) that can be accessed by at most one thread at a time (either by the "bear" thread or by one of the "honeybee" threads). 

Develop a monitor (with condition variables) to synchronize the actions of the bear and honeybees, i.e. develop a monitor that represents the pot of honey. Define the monitor's operations and their implementation. Implement a multithreaded application in Java to simulate the actions of the bear and honeybees represented as concurrent threads and the pot represented as as the monitor.
7. The One-Lane Bridge Problem (similar to the Readers/Writers problem) 

Assume, cars coming from the north and the south arrive at a one-lane bridge. Cars heading in the same direction can cross the bridge at the same time, but cars heading in opposite directions cannot.
Develop and implement a multithreaded program in Java to simulate actions of the cars.  Each car should be a thread that crosses the bridge trips times, first in one direction, then in the other direction, and so on. Use northCars instances of cars that first cross in a northbound direction, and use southCars instances of cars that first cross in a southbound direction. Use a monitor to control entry to the bridge. It should have operations that a car calls to ask permission to cross the bridge and to indicate that it has finished crossing the bridge. You will want to have two or four operations depending on how you program the cars threads. (After you think about the choices, you will understand what the last sentence means!). Your solution has to ensure the required exclusion and avoid deadlocks, and ensure fairness, i.e. to ensure that any car that is waiting to cross the bridge eventually gets to do so.

Your program should have three command-line arguments, for the values of trips, northCars, and southCars. Have the cars sleep for a random amount of time between crossings of the bridge and have them sleep for a smaller random amount of time to simulate the time it takes to cross the bridge. Stop the simulation after each car has crossed the bridge trips times.

The output from your program should be a trace of the significant events that occur, such as a car wanting to cross the bridge, starting to cross, or leaving the bridge. Each line of output should contain a time stamp, the identity of the car associated with the event, and a short descriptive message. Write the trace to the standard output.
8. The Unisex Bathroom Problem (similar to the Readers/Writers problem) 

Suppose there is only one bathroom in a building. It can be used by any number of men or any number of women, but not at the same time. 
(a) Develop a monitor to synchronize the use of the bathroom. The monitor has four public procedures: manEnter, manExit, womanEnter, and womanExit. A man thread calls manEnter to get permission to use the bathroom and calls manExit when finished. A woman thread calls womanEnter and womanExit. Use the Signal and Continue signaling discipline (which is the default discipline). Your solution has to ensure the required exclusion and avoid deadlock, and ensure fairness, i.e. ensure that any person (man or woman) which is waiting to enter the bathroom eventually gets to do so
(b) Implement a multithreaded application in Java to simulate the actions of the "man" and "woman" threads represented as concurrent threads and the bathroom represented as as a monitor. The output from your program should be a trace of the significant events that occur, such as a person wanting to enter the bathroom, entering or exiting the room. Each line of output should contain a time stamp, the identity of the person associated with the event, and a short descriptive message. Write the trace to the standard output.




Programming environments (language and libraries):
C/C++ with OpenMP 3.0 (needed if tasking is to be explored). Implemented by:
gcc version 4.4 or later (available on KTH laptops and the KTH server gothmog.it.kth.se) and easy to download and install on any Linux distribution. (Cygwin users may need to build it themselves). Compile an OpenMP program using -fopenmp
Optional: Intel Parallel studio xe 2011 (available for personal non-commercial use for Linux from intel.com). Compile an OpenMP program using -openmp. You can download a trial (30 days) version of the Intel Parallel Studio xe 2011 for Windows (requires MS Visual Studio).
C/C++ with OpenMP 2.0. Implemented by:
gcc 4.2 or later. Compile an OpenMP program using -fopenmp
Objectives:

You learn how
to write, build and execute a parallel program in OpenMP showing performance speedup on more than one processor
to find dependences in loops and to write the code so that it can correctly be executed in parallel
Task

You are to solve one of the following problems. You may discuss the meaning of problems with classmates, but the work you turn in must be yours alone.
Problems

1. Compute Sum, Min and Max of Matrix Element

The purpose of this problem is to introduce you to the basic OpenMP usage:
Download, compile and run a program matrixSum-openmp.c. The program computes a sum of matrix elements in parallel using OpenMP.
(a) Extend the program so that in addition to sum it finds and prints a value and a position (indexes) of the maximum element of the matrix, and a value and a position of the minimum element of the matrix.  Initialize elements of the matrix to random values to check your solution. Use OpenMP constructs.
(b) Change the program developed in (a) so that the master thread prints the final results. Do not use explicit barriers and do not use arrays for partial results, such as  sums in the pthreads example.
(c) Run the program on different number of processors and report the speedup (sequential execution time divided by parallel execution time) for different number of processors (up to at least 4) and different sizes of matrices (at least 3 different sizes). Run each program several (at least 5) times and use the median value for execution time. Try to provide reasonable explanations to your  results. Measure only the parallel part of your program and try to adapt the workload so that the sequential execution time is at least 1-2 seconds. Specify the number of processors used by specifying different number of threads (set the OMP_NUM_THREADS environment variable or use a call to omp_set_num_threads(), see the OpenMP specification). 
To measure the execution time, use  the omp_get_wtime function (see omp_get_wtime).
2. Quicksort

The quicksort algorithm sorts the list of numbers by first dividing the list into two sublists, so that all the numbers if one sublist  are smaller than all the numbers in the other sublist. This is done by selecting one number (called a pivot) against which all other number are compared: the numbers which are less then the pivot are placed in one sublist, the numbers which more than the pivot are placed in another sublist. The pivot can be either placed in one sublist or could be withheld and placed in its final position. 

Develop a parallel multithreaded program (in C/C++ using OpenMP tasks) with recursive parallelism that implements the quicksort algorithm for sorting an array of n values. 

Run the program on different number of processors and report the speedup (sequential execution time divided by parallel execution time) for different number of processors (up to at least 4) and different workloads (at least 3 different lists of different sizes). Run each program several (at least 5)  times and use the median value for execution time. Try to provide reasonable explanations to your  results. Measure only the parallel part of your program and try to adapt the workload so that the sequential execution time is at least 1-2 seconds. Specify the number of processors used by specifying different number of threads (set the OMP_NUM_THREADS environment variable or use a call to omp_set_num_threads(), see the OpenMP specification).
To measure the execution time, use  the omp_get_wtime function (see omp_get_wtime).
3. Find Palindromic Words

Develop a parallel multithreaded program (in C/C++ using OpenMP) to solve the following problem. There is an online dictionary in /usr/dict/words under Linux or Solaris. The file contains 25,143 words (and is used by the Unix spell command). You can download the file words. Recall that a palindrome is a word or phrase that reads the same in either direction, i.e., if you reverse all the letters you get the same word or phrase. Your task is to find all palindromic words in the dictionary. A word is palindromic if its reverse is also in the dictionary. For example, "noon" is palindromic, because it is a palindrome and hence it's reverse is trivially in the dictionary. A word like "draw" is palindromic because "ward" is also in the dictionary. 
Your parallel program should use for-loop parallelism or tasks and the number of threads used should be a command-line argument. Do the input and output phases sequentially and the rest in parallel. Your program should write the palindromic words to a results file. 

Run the program on different number of processors and report the speedup (sequential execution time divided by parallel execution time) for different number of processors (up to at least 4) and different workloads (at least 3 different sizes of a dictionary). Run each program several times (at least 5) and use the median value for execution time. Try to provide reasonable explanations to your  results. Measure only the parallel part of your program and try to adapt the workload so that the sequential execution time is at least 1-2 seconds. Specify the number of processors used by specifying different number of threads (set the OMP_NUM_THREADS environment variable or use a call to omp_set_num_threads(), see the OpenMP specification).
To measure the execution time, use  the omp_get_wtime function (see omp_get_wtime).
4. The 8-queens problem
The 8-queens problem is concerned with placing 8 queens on a chess board in such a way that no one queen can attack another. One can attack another if both are in the same row or column or are on the same diagonal.
Develop a parallel  program (in C/C++ usingOpenMP) to generate all 92 solutions to the 8-queens problem. [Hint: You can use tasks so that the master thread recursively generates queen placements and other tasks to check whether  placements are acceptable.]

Run the program on different number of processors and report the speedup (sequential execution time divided by parallel execution time) for different number of processors (up to at least 4). Run each program several (at least 5) times and use the median value for execution time. Try to provide reasonable explanations to your  results. Measure only the parallel part of your program and try to adapt the workload so that the sequential execution time is at least 1-2 seconds (you might need to repeat the calculation to get reasonable execution times). Specify the number of processors used by specifying different number of threads (set the OMP_NUM_THREADS environment variable or use a call to omp_set_num_threads(), see the OpenMP specification).
To measure the execution time, use  the omp_get_wtime function (see omp_get_wtime).



</div>

</div>

</body>
</html>